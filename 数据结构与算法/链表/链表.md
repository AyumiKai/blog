1.什么是链表？
  - 根据下图来对比下数组和链表之间的内存分布，数组需要一块连续的内存空间来存储，对内存的要求比较高，如果我们申请一个100MB大小的数组，当内存中没有连续、足够大的存储空间时，即便内存的剩余可用空间大于100MB，仍然会申请失败。而链表恰恰与之相反，它并不需要一块连续的内存空间，它通过指针将一组零散的内存块串联起来使用，所以如果我们申请的是100MB大小的链表，也不会有问题。
  ![链表](https://static001.geekbang.org/resource/image/d5/cd/d5d5bee4be28326ba3c28373808a62cd.jpg)

2.常见的链表类型
  - 单链表
      单链表是最简单、常用的链表类型，链表通过指针将一组零散的内存块串联一起。其中，我们把内存块成为链表的结点。为了将所有的结点串起来，每个链表的结点除了存储数据之外，还需要记录链表上面的一个结点的地址。如下图所示，我们把这个记录下个结点的指针叫做**后继指针next**。
      ![单链表](https://static001.geekbang.org/resource/image/b9/eb/b93e7ade9bb927baad1348d9a806ddeb.jpg)
      其中有两个结点比较特殊，它们分别是第一个结点和最后一个结点，习惯性地把第一个结点叫作头结点，最后一个结点叫作尾结点，其中，头结点用来记录链表的基地址，有了它，就能遍历得到整条链表，而尾结点特殊的地方是:指针不是指向下一个结点，而是指向一个**空地址NULL**，表示这是链表的最后一个结点。与数组一样，链表也支持数据的查找、插入和删除等操作。我们知道，在进行数组的插入、删除操作时，为了保持内存数据的连续性，需要做大量的数据搬移，所以时间复杂度是O(n)。而在链表中插入或删除一个数据，我们并不需要为了保持内存的连续性而搬移结点，因为链表的存储空间不是连续的，所以在链表上插入和删除一个数据是非常快速的。如下图，链表的插入和删除操作都只需要考虑相邻结点的指针改变，所以对应的时间复杂度是O(1)。
      ![链表的插入和删除](https://static001.geekbang.org/resource/image/45/17/452e943788bdeea462d364389bd08a17.jpg)
      有利也有弊，链表要想随机访问第k个元素的话就没有数组那么高效，因为链表中的数据并非连续存储，所以无法像数组那样，根据首地址和下标(a[k]_address = base_address + k * type_size)，通过寻址公式就能直接计算出对应的内存地址，而是需要指针一个结点一个结点依次地遍历，直到找到相应的结点。故链表的随机访问某个结点的时间复杂度为O(n)。
  - 双向链表
      单链表只有一个方向，结点只有一个后继指针next指向后面的结点，而双向链表，顾名思义，它支持两个方向，每个结点不止有一个后继next指向后面的结点，还有一个前驱指针prev指向前面的结点。![双向链表](https://static001.geekbang.org/resource/image/cb/0b/cbc8ab20276e2f9312030c313a9ef70b.jpg)从图中可以看出，双向链表需要额外的两个空间来存储后继结点和前驱结点的地址。所以，如果存储同样多的数据，双向链表比单链表占用更多的空间。虽然两个指针比较浪费存储空间，但可以支持双向遍历，这样也带来了双向链表操作的灵活性。相比单链表，双向链表在某些情况下更简单、高效，比如**删除操作**，假设有两种删除一个数据的场景

        删除结点中“值等于某个给定值”的结点
        删除给定指针指向的结点
      
      尽管单纯的删除操作时间复杂度是O(1)，但遍历查找的时间是主要的耗时点，对应的时间复杂度为O(n),根据时间复杂度分析中的加法法则，删除值等于给定值的结点对应的链表操作的总时间复杂度为O(n)。

      对于第二种情况，我们已经找到了要删除的结点，但是删除某个结点q需要知道其前驱结点，而单链表并不支持直接获取前驱结点，所以为了找到前驱结点，我们还是要从头结点开始遍历链表，直到p->next=q,说明p是q的前驱结点。

      但是对于双向链表来说，这种情况下就比较有优势，因为双向链表中的结点已经保存了前驱结点的指针，不需要像单链表那样遍历，所以针对第二种情况，单链表删除操作需要O(n)的时间复杂度，而双向链表只需要在O(1)的时间复杂度内就可以了。

      同理，我们希望在链表的某个指定结点前面插入一个结点，双向链表比单链表有很大的优势。双向链表可以在O(1)时间复杂度搞定，而单向链表需要O(n)的时间复杂度。

      除了插入、删除操作有优势之外，对于一个有序链表，双向链表的按值查询的效率也要比单链表高一些。因为，我们可以记录上次查找的位置p，每次查询时，根据要查找的值与p的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。双向链表在Java语言中的LinkedHashMap中就有用到。实际上双向链表的设计理念这就是典型的**用空间换时间**的设计思想。当内存空间充足的时候，如果我们更加追求代码的执行速度，我们就可以选择空间复杂度相对较高、但时间复杂度相对很低的算法或数据结构。相反，如果内存比较紧缺，比如代码跑在手机或者单片机上的话，这个时候，就要反过来用时间换空间的设计思路。

      循环链表和双向列表的结合就是**双向循环链表**。![双向循环链表](https://static001.geekbang.org/resource/image/d1/91/d1665043b283ecdf79b157cfc9e5ed91.jpg)
  - 循环链表
      **循环链表是一种特殊的单链表**。循环链表跟单链表唯一的区别就在尾结点，单链表的尾结点指针指向空地址，表示这就是最后的结点来，而循环链表的尾结点指针是指向链表的头结点。如下图所示![循环链表](https://static001.geekbang.org/resource/image/86/55/86cb7dc331ea958b0a108b911f38d155.jpg)
3. 链表对比数组
    ![链表对比数组](https://static001.geekbang.org/resource/image/4f/68/4f63e92598ec2551069a0eef69db7168.jpg)